{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.element = exports.text = exports.comment = exports.root = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _all = _interopRequireDefault(require(\"./all\"));\n\nvar _getAttributes = _interopRequireDefault(require(\"./getAttributes\"));\n\nvar _mappings = require(\"./mappings\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst root = (h, node) => t.program((0, _all.default)(h, node));\n\nexports.root = root;\n\nconst comment = (h, node, parent) => {\n  if (parent.type === 'root') {\n    return null;\n  }\n\n  const expression = t.jsxEmptyExpression();\n  t.addComment(expression, 'inner', node.value);\n  return t.jsxExpressionContainer(expression);\n};\n\nexports.comment = comment;\n\nconst text = (h, node, parent) => {\n  if (parent.type === 'root') {\n    return null;\n  }\n\n  if (node.value.match(/^\\s+$/)) {\n    return null;\n  }\n\n  return t.jsxExpressionContainer(t.stringLiteral(node.value));\n};\n\nexports.text = text;\n\nconst element = (h, node, parent) => {\n  const children = (0, _all.default)(h, node);\n  const selfClosing = children.length === 0;\n  const name = _mappings.ELEMENT_TAG_NAME_MAPPING[node.tagName] || node.tagName;\n  const openingElement = t.jsxOpeningElement(t.jsxIdentifier(name), (0, _getAttributes.default)(node), selfClosing);\n  const closingElement = !selfClosing ? t.jsxClosingElement(t.jsxIdentifier(name)) : null;\n  const jsxElement = t.jsxElement(openingElement, closingElement, children);\n\n  if (parent.type === 'root') {\n    return t.expressionStatement(jsxElement);\n  }\n\n  return jsxElement;\n};\n\nexports.element = element;","map":null,"metadata":{},"sourceType":"script"}