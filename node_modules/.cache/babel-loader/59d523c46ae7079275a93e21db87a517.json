{"ast":null,"code":"//      \n'use strict';\n\nconst path = require('path');\n\nconst loaders = require('./loaders');\n\nconst readFile = require('./readFile');\n\nconst cacheWrapper = require('./cacheWrapper');\n\nconst getDirectory = require('./getDirectory');\n\nconst getPropertyByPath = require('./getPropertyByPath');\n\nconst MODE_SYNC = 'sync'; // An object value represents a config object.\n// null represents that the loader did not find anything relevant.\n// undefined represents that the loader found something relevant\n// but it was empty.\n\nclass Explorer {\n  constructor(options) {\n    this.loadCache = options.cache ? new Map() : null;\n    this.loadSyncCache = options.cache ? new Map() : null;\n    this.searchCache = options.cache ? new Map() : null;\n    this.searchSyncCache = options.cache ? new Map() : null;\n    this.config = options;\n    this.validateConfig();\n  }\n\n  clearLoadCache() {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n\n    if (this.loadSyncCache) {\n      this.loadSyncCache.clear();\n    }\n  }\n\n  clearSearchCache() {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n\n    if (this.searchSyncCache) {\n      this.searchSyncCache.clear();\n    }\n  }\n\n  clearCaches() {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  validateConfig() {\n    const config = this.config;\n    config.searchPlaces.forEach(place => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n\n      if (!loader) {\n        throw new Error(\"No loader specified for \".concat(getExtensionDescription(place), \", so searchPlaces item \\\"\").concat(place, \"\\\" is invalid\"));\n      }\n    });\n  }\n\n  search(searchFrom) {\n    searchFrom = searchFrom || process.cwd();\n    return getDirectory(searchFrom).then(dir => {\n      return this.searchFromDirectory(dir);\n    });\n  }\n\n  searchFromDirectory(dir) {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = () => {\n      return this.searchDirectory(absoluteDir).then(result => {\n        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n        if (nextDir) {\n          return this.searchFromDirectory(nextDir);\n        }\n\n        return this.config.transform(result);\n      });\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  searchSync(searchFrom) {\n    searchFrom = searchFrom || process.cwd();\n    const dir = getDirectory.sync(searchFrom);\n    return this.searchFromDirectorySync(dir);\n  }\n\n  searchFromDirectorySync(dir) {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = () => {\n      const result = this.searchDirectorySync(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n      if (nextDir) {\n        return this.searchFromDirectorySync(nextDir);\n      }\n\n      return this.config.transform(result);\n    };\n\n    if (this.searchSyncCache) {\n      return cacheWrapper(this.searchSyncCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  searchDirectory(dir) {\n    return this.config.searchPlaces.reduce((prevResultPromise, place) => {\n      return prevResultPromise.then(prevResult => {\n        if (this.shouldSearchStopWithResult(prevResult)) {\n          return prevResult;\n        }\n\n        return this.loadSearchPlace(dir, place);\n      });\n    }, Promise.resolve(null));\n  }\n\n  searchDirectorySync(dir) {\n    let result = null;\n\n    for (const place of this.config.searchPlaces) {\n      result = this.loadSearchPlaceSync(dir, place);\n      if (this.shouldSearchStopWithResult(result)) break;\n    }\n\n    return result;\n  }\n\n  shouldSearchStopWithResult(result) {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  loadSearchPlace(dir, place) {\n    const filepath = path.join(dir, place);\n    return readFile(filepath).then(content => {\n      return this.createCosmiconfigResult(filepath, content);\n    });\n  }\n\n  loadSearchPlaceSync(dir, place) {\n    const filepath = path.join(dir, place);\n    const content = readFile.sync(filepath);\n    return this.createCosmiconfigResultSync(filepath, content);\n  }\n\n  nextDirectoryToSearch(currentDir, currentResult) {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n\n    const nextDir = nextDirUp(currentDir);\n\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n\n    return nextDir;\n  }\n\n  loadPackageProp(filepath, content) {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(parsedContent, this.config.packageProp);\n    return packagePropValue || null;\n  }\n\n  getLoaderEntryForFile(filepath) {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return {\n        sync: loader,\n        async: loader\n      };\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n    return this.config.loaders[loaderKey] || {};\n  }\n\n  getSyncLoaderForFile(filepath) {\n    const entry = this.getLoaderEntryForFile(filepath);\n\n    if (!entry.sync) {\n      throw new Error(\"No sync loader specified for \".concat(getExtensionDescription(filepath)));\n    }\n\n    return entry.sync;\n  }\n\n  getAsyncLoaderForFile(filepath) {\n    const entry = this.getLoaderEntryForFile(filepath);\n    const loader = entry.async || entry.sync;\n\n    if (!loader) {\n      throw new Error(\"No async loader specified for \".concat(getExtensionDescription(filepath)));\n    }\n\n    return loader;\n  }\n\n  loadFileContent(mode, filepath, content) {\n    if (content === null) {\n      return null;\n    }\n\n    if (content.trim() === '') {\n      return undefined;\n    }\n\n    const loader = mode === MODE_SYNC ? this.getSyncLoaderForFile(filepath) : this.getAsyncLoaderForFile(filepath);\n    return loader(filepath, content);\n  }\n\n  loadedContentToCosmiconfigResult(filepath, loadedContent) {\n    if (loadedContent === null) {\n      return null;\n    }\n\n    if (loadedContent === undefined) {\n      return {\n        filepath,\n        config: undefined,\n        isEmpty: true\n      };\n    }\n\n    return {\n      config: loadedContent,\n      filepath\n    };\n  }\n\n  createCosmiconfigResult(filepath, content) {\n    return Promise.resolve().then(() => {\n      return this.loadFileContent('async', filepath, content);\n    }).then(loaderResult => {\n      return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n    });\n  }\n\n  createCosmiconfigResultSync(filepath, content) {\n    const loaderResult = this.loadFileContent('sync', filepath, content);\n    return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n  }\n\n  validateFilePath(filepath) {\n    if (!filepath) {\n      throw new Error('load and loadSync must pass a non-empty string');\n    }\n  }\n\n  load(filepath) {\n    return Promise.resolve().then(() => {\n      this.validateFilePath(filepath);\n      const absoluteFilePath = path.resolve(process.cwd(), filepath);\n      return cacheWrapper(this.loadCache, absoluteFilePath, () => {\n        return readFile(absoluteFilePath, {\n          throwNotFound: true\n        }).then(content => {\n          return this.createCosmiconfigResult(absoluteFilePath, content);\n        }).then(this.config.transform);\n      });\n    });\n  }\n\n  loadSync(filepath) {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n    return cacheWrapper(this.loadSyncCache, absoluteFilePath, () => {\n      const content = readFile.sync(absoluteFilePath, {\n        throwNotFound: true\n      });\n      const result = this.createCosmiconfigResultSync(absoluteFilePath, content);\n      return this.config.transform(result);\n    });\n  }\n\n}\n\nmodule.exports = function createExplorer(options) {\n  const explorer = new Explorer(options);\n  return {\n    search: explorer.search.bind(explorer),\n    searchSync: explorer.searchSync.bind(explorer),\n    load: explorer.load.bind(explorer),\n    loadSync: explorer.loadSync.bind(explorer),\n    clearLoadCache: explorer.clearLoadCache.bind(explorer),\n    clearSearchCache: explorer.clearSearchCache.bind(explorer),\n    clearCaches: explorer.clearCaches.bind(explorer)\n  };\n};\n\nfunction nextDirUp(dir) {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath) {\n  const ext = path.extname(filepath);\n  return ext ? \"extension \\\"\".concat(ext, \"\\\"\") : 'files without extensions';\n}","map":null,"metadata":{},"sourceType":"script"}